use anyhow::{Context, Result, bail};
use parser::class::constant_pool::CpIndex;

fn cp_index(bytes: &[u8]) -> Result<CpIndex> {
    let byte1 = *bytes.get(1).context("premature end of code")?;
    let byte2 = *bytes.get(2).context("premature end of code")?;
    Ok(((byte1 as u16) << 8 | byte2 as u16).into())
}

fn offset(bytes: &[u8]) -> Result<i16> {
    let byte1 = *bytes.get(1).context("premature end of code")?;
    let byte2 = *bytes.get(2).context("premature end of code")?;
    Ok((byte1 as i16) << 8 | byte2 as i16)
}

fn short(bytes: &[u8]) -> Result<u16> {
    let byte1 = *bytes.get(1).context("premature end of code")?;
    let byte2 = *bytes.get(2).context("premature end of code")?;
    Ok((byte1 as u16) << 8 | byte2 as u16)
}

#[derive(Debug, Clone)]
pub enum Instruction {
    Iconst(i8),
    Ldc(CpIndex),
    Return,
    PutStatic(CpIndex),
    InvokeVirtual(CpIndex),
    InvokeStatic(CpIndex),
    Anewarray(CpIndex),
    Aload(u8),
    Pop,
    Aload0,
    Aload1,
    Aload2,
    Aload3,
    GetField(CpIndex),
    Astore(u8),
    IfNull(i16),
    Areturn,
    Dreturn,
    InvokeDynamic(CpIndex),
    New(CpIndex),
    Dup,
    Dup2,
    InvokeSpecial(CpIndex),
    IfNonNull(i16),
    Ireturn,
    IfNe(i16),
    GetStatic(CpIndex),
    LdcW(CpIndex),
    PutField(CpIndex),
    Iload(u8),
    Iload0,
    Iload1,
    Iload2,
    Iload3,
    AconstNull,
    Aastore,
    Bipush(u8),
    Newarray(u8),
    Castore,
    Bastore,
    Iastore,
    Sipush(u16),
    Lreturn,
    Istore(u8),
    Isub,
    Iand,
    Ifeq(i16),
    Goto(i16),
    Ifgt(i16),
    Fload0,
    Fload1,
    Fload2,
    Fload3,
    Fconst(f32),
    Fcmpg,
    Fcmpl,
    Ifle(i16),
    Iflt(i16),
    IfIcmpge(i16),
    Dconst(f64),
    I2l,
    I2f,
    L2f,
    Fdiv,
    F2d,
    F2i,
    Dadd,
    Fadd,
    D2l,
    Lstore(u8),
    Fstore(u8),
    Lload(u8),
    Fload(u8),
    Ldc2W(CpIndex),
    Lcmp,
    L2i,
    IfIcmplt(i16),
    Iinc(u8, i8),
    Iushr,
    Lushr,
    Ifge(i16),
    Iadd,
    Lconst(i64),
    IfIcmpeq(i16),
    ArrayLength,
    Ishr,
    Lshr,
    Land,
    Ixor,
    Baload,
    I2c,
    I2b,
    IfIcmpne(i16),
    IfIcmpgt(i16),
    IfIcmple(i16),
    IfAcmpne(i16),
    Instanceof(CpIndex),
    Checkcast(CpIndex),
    Lstore0,
    Lstore1,
    Lstore2,
    Lstore3,
    Istore0,
    Istore1,
    Istore2,
    Istore3,
    Astore0,
    Astore1,
    Astore2,
    Astore3,
    Lload0,
    Lload1,
    Lload2,
    Lload3,
    Lmul,
    Fmul,
    Idiv,
    Ladd,
    Imul,
    InvokeInterface(CpIndex, u8),
    DupX1,
    Aaload,
    Lshl,
    Ishl,
    MonitorEnter,
    MonitorExit,
    Irem,
    Ineg,
    TableSwitch {
        skip: usize,
        default: i32,
        low: i32,
        high: i32,
        jump_offsets: Vec<i32>,
    },
}

impl Instruction {
    pub fn new(bytes: &[u8], pc: usize) -> Result<Self> {
        Ok(match bytes.first().context("premature end of code")? {
            0x1 => Instruction::AconstNull,
            0x2 => Instruction::Iconst(-1),
            0x3 => Instruction::Iconst(0),
            0x4 => Instruction::Iconst(1),
            0x5 => Instruction::Iconst(2),
            0x6 => Instruction::Iconst(3),
            0x7 => Instruction::Iconst(4),
            0x8 => Instruction::Iconst(5),
            0x9 => Instruction::Lconst(0),
            0xa => Instruction::Lconst(1),
            0x10 => Instruction::Bipush(*bytes.get(1).context("premature end of code")?),
            0x11 => Instruction::Sipush(short(bytes)?),
            0x12 => Instruction::Ldc((*bytes.get(1).context("premature end of code")?).into()),
            0x13 => Instruction::LdcW(cp_index(bytes)?),
            0x17 => Instruction::Fload(*bytes.get(1).context("premature end of code")?),
            0x19 => Instruction::Aload(*bytes.get(1).context("premature end of code")?),
            0x1e => Instruction::Lload0,
            0x1f => Instruction::Lload1,
            0x20 => Instruction::Lload2,
            0x21 => Instruction::Lload3,
            0xb => Instruction::Fconst(0.0),
            0xc => Instruction::Fconst(1.0),
            0xd => Instruction::Fconst(2.0),
            0xe => Instruction::Dconst(0.0),
            0xf => Instruction::Dconst(1.0),
            0x14 => Instruction::Ldc2W(cp_index(bytes)?),
            0x15 => Instruction::Iload(*bytes.get(1).context("premature end of code")?),
            0x16 => Instruction::Lload(*bytes.get(1).context("premature end of code")?),
            0x1a => Instruction::Iload0,
            0x1b => Instruction::Iload1,
            0x1c => Instruction::Iload2,
            0x1d => Instruction::Iload3,
            0x22 => Instruction::Fload0,
            0x23 => Instruction::Fload1,
            0x24 => Instruction::Fload2,
            0x25 => Instruction::Fload3,
            0x2a => Instruction::Aload0,
            0x2b => Instruction::Aload1,
            0x2c => Instruction::Aload2,
            0x2d => Instruction::Aload3,
            0x32 => Instruction::Aaload,
            0x33 => Instruction::Baload,
            0x36 => Instruction::Istore(*bytes.get(1).context("premature end of code")?),
            0x37 => Instruction::Lstore(*bytes.get(1).context("premature end of code")?),
            0x38 => Instruction::Fstore(*bytes.get(1).context("premature end of code")?),
            0x3a => Instruction::Astore(*bytes.get(1).context("premature end of code")?),
            0x3b => Instruction::Istore0,
            0x3c => Instruction::Istore1,
            0x3d => Instruction::Istore2,
            0x3e => Instruction::Istore3,
            0x3f => Instruction::Lstore0,
            0x40 => Instruction::Lstore1,
            0x41 => Instruction::Lstore2,
            0x42 => Instruction::Lstore3,
            0x4b => Instruction::Astore0,
            0x4c => Instruction::Astore1,
            0x4d => Instruction::Astore2,
            0x4e => Instruction::Astore3,
            0x4f => Instruction::Iastore,
            0x53 => Instruction::Aastore,
            0x54 => Instruction::Bastore,
            0x55 => Instruction::Castore,
            0x57 => Instruction::Pop,
            0x59 => Instruction::Dup,
            0x5a => Instruction::DupX1,
            0x5c => Instruction::Dup2,
            0x60 => Instruction::Iadd,
            0x61 => Instruction::Ladd,
            0x62 => Instruction::Fadd,
            0x63 => Instruction::Dadd,
            0x64 => Instruction::Isub,
            0x68 => Instruction::Imul,
            0x69 => Instruction::Lmul,
            0x6a => Instruction::Fmul,
            0x6c => Instruction::Idiv,
            0x6e => Instruction::Fdiv,
            0x70 => Instruction::Irem,
            0x74 => Instruction::Ineg,
            0x78 => Instruction::Ishl,
            0x79 => Instruction::Lshl,
            0x7a => Instruction::Ishr,
            0x7b => Instruction::Lshr,
            0x7c => Instruction::Iushr,
            0x7d => Instruction::Lushr,
            0x7e => Instruction::Iand,
            0x7f => Instruction::Land,
            0x82 => Instruction::Ixor,
            0x84 => Instruction::Iinc(
                *bytes.get(1).context("premature end of code")?,
                *bytes.get(2).context("premature end of code")? as i8,
            ),
            0x85 => Instruction::I2l,
            0x86 => Instruction::I2f,
            0x88 => Instruction::L2i,
            0x89 => Instruction::L2f,
            0x8b => Instruction::F2i,
            0x8d => Instruction::F2d,
            0x8f => Instruction::D2l,
            0x91 => Instruction::I2b,
            0x92 => Instruction::I2c,
            0x94 => Instruction::Lcmp,
            0x95 => Instruction::Fcmpl,
            0x96 => Instruction::Fcmpg,
            0x99 => Instruction::Ifeq(offset(bytes)?),
            0x9a => Instruction::IfNe(offset(bytes)?),
            0x9b => Instruction::Iflt(offset(bytes)?),
            0x9c => Instruction::Ifge(offset(bytes)?),
            0x9d => Instruction::Ifgt(offset(bytes)?),
            0x9e => Instruction::Ifle(offset(bytes)?),
            0x9f => Instruction::IfIcmpeq(offset(bytes)?),
            0xa0 => Instruction::IfIcmpne(offset(bytes)?),
            0xa1 => Instruction::IfIcmplt(offset(bytes)?),
            0xa2 => Instruction::IfIcmpge(offset(bytes)?),
            0xa3 => Instruction::IfIcmpgt(offset(bytes)?),
            0xa4 => Instruction::IfIcmple(offset(bytes)?),
            0xa6 => Instruction::IfAcmpne(offset(bytes)?),
            0xa7 => Instruction::Goto(offset(bytes)?),
            0xaa => table_switch(bytes, pc)?,
            0xac => Instruction::Ireturn,
            0xad => Instruction::Lreturn,
            0xaf => Instruction::Dreturn,
            0xb0 => Instruction::Areturn,
            0xb1 => Instruction::Return,
            0xb2 => Instruction::GetStatic(cp_index(bytes)?),
            0xb3 => Instruction::PutStatic(cp_index(bytes)?),
            0xb4 => Instruction::GetField(cp_index(bytes)?),
            0xb5 => Instruction::PutField(cp_index(bytes)?),
            0xb6 => Instruction::InvokeVirtual(cp_index(bytes)?),
            0xb7 => Instruction::InvokeSpecial(cp_index(bytes)?),
            0xb8 => Instruction::InvokeStatic(cp_index(bytes)?),
            0xb9 => Instruction::InvokeInterface(
                cp_index(bytes)?,
                *bytes.get(3).context("premature end of code")?,
            ),
            0xba => Instruction::InvokeDynamic(cp_index(bytes)?),
            0xbb => Instruction::New(cp_index(bytes)?),
            0xbc => Instruction::Newarray(*bytes.get(1).context("premature end of code")?),
            0xbd => Instruction::Anewarray(cp_index(bytes)?),
            0xbe => Instruction::ArrayLength,
            0xc0 => Instruction::Checkcast(cp_index(bytes)?),
            0xc2 => Instruction::MonitorEnter,
            0xc3 => Instruction::MonitorExit,
            0xc1 => Instruction::Instanceof(cp_index(bytes)?),
            0xc6 => Instruction::IfNull(offset(bytes)?),
            0xc7 => Instruction::IfNonNull(offset(bytes)?),
            op_code => bail!("unknown instruction: 0x{op_code:x}"),
        })
    }

    pub fn length(&self) -> usize {
        match self {
            Self::Iconst(_) => 1,
            Self::Ldc(_) => 2,
            Self::Return => 1,
            Self::PutStatic(_) => 3,
            Self::InvokeVirtual(_) => 3,
            Self::InvokeStatic(_) => 3,
            Self::Anewarray(_) => 3,
            Self::GetField(_) => 3,
            Self::Astore(_) => 2,
            Self::IfNull(_) => 3,
            Self::Areturn => 1,
            Self::InvokeDynamic(_) => 5,
            Self::New(_) => 3,
            Self::Dup => 1,
            Self::Dup2 => 1,
            Self::InvokeSpecial(_) => 3,
            Self::IfNonNull(_) => 3,
            Self::Ireturn => 1,
            Self::IfNe(_) => 3,
            Self::GetStatic(_) => 3,
            Self::LdcW(_) => 3,
            Self::PutField(_) => 3,
            Self::Iload(_) => 2,
            Self::AconstNull => 1,
            Self::Aastore => 1,
            Self::Bipush(_) => 2,
            Self::Newarray(_) => 2,
            Self::Castore => 1,
            Self::Bastore => 1,
            Self::Iastore => 1,
            Self::Sipush(_) => 3,
            Self::Lreturn => 1,
            Self::Istore(_) => 2,
            Self::Isub => 1,
            Self::Iand => 1,
            Self::Ifeq(_) => 3,
            Self::Goto(_) => 3,
            Self::Ifgt(_) => 3,
            Self::Fconst(_) => 1,
            Self::Fcmpl => 1,
            Self::Ifle(_) => 3,
            Self::Iflt(_) => 3,
            Self::IfIcmpge(_) => 3,
            Self::Dconst(_) => 1,
            Self::I2l => 1,
            Self::I2f => 1,
            Self::L2f => 1,
            Self::Fdiv => 1,
            Self::F2d => 1,
            Self::Dadd => 1,
            Self::Fadd => 1,
            Self::D2l => 1,
            Self::Lstore(_) => 2,
            Self::Fstore(_) => 2,
            Self::Lload(_) => 2,
            Self::Ldc2W(_) => 3,
            Self::Lcmp => 1,
            Self::L2i => 1,
            Self::IfIcmplt(_) => 3,
            Self::Iinc(_, _) => 3,
            Self::Iushr => 1,
            Self::Lushr => 1,
            Self::Ifge(_) => 3,
            Self::Iadd => 1,
            Self::Iload0 => 1,
            Self::Iload1 => 1,
            Self::Iload2 => 1,
            Self::Iload3 => 1,
            Self::Fload0 => 1,
            Self::Fload1 => 1,
            Self::Fload2 => 1,
            Self::Fload3 => 1,
            Self::Aload0 => 1,
            Self::Aload1 => 1,
            Self::Aload2 => 1,
            Self::Aload3 => 1,
            Self::Lconst(_) => 1,
            Self::IfIcmpeq(_) => 3,
            Self::ArrayLength => 1,
            Self::Ishr => 1,
            Self::Baload => 1,
            Self::I2c => 1,
            Self::I2b => 1,
            Self::IfIcmpne(_) => 3,
            Self::IfIcmpgt(_) => 3,
            Self::IfIcmple(_) => 3,
            Self::IfAcmpne(_) => 3,
            Self::Instanceof(_) => 3,
            Self::Checkcast(_) => 3,
            Self::Lstore0 => 1,
            Self::Lstore1 => 1,
            Self::Lstore2 => 1,
            Self::Lstore3 => 1,
            Self::Istore0 => 1,
            Self::Istore1 => 1,
            Self::Istore2 => 1,
            Self::Istore3 => 1,
            Self::Astore0 => 1,
            Self::Astore1 => 1,
            Self::Astore2 => 1,
            Self::Astore3 => 1,
            Self::Lload0 => 1,
            Self::Lload1 => 1,
            Self::Lload2 => 1,
            Self::Lload3 => 1,
            Self::Lmul => 1,
            Self::Imul => 1,
            Self::Lshr => 1,
            Self::Land => 1,
            Self::Ladd => 1,
            Self::InvokeInterface(_, _) => 5,
            Self::Aload(_) => 2,
            Self::Pop => 1,
            Self::Ixor => 1,
            Self::DupX1 => 1,
            Self::Aaload => 1,
            Self::Dreturn => 1,
            Self::Lshl => 1,
            Self::Ishl => 1,
            Self::MonitorEnter => 1,
            Self::MonitorExit => 1,
            Self::Irem => 1,
            Self::Ineg => 1,
            Self::Fload(_) => 2,
            Self::Fcmpg => 1,
            Self::F2i => 1,
            Self::Fmul => 1,
            Self::TableSwitch {
                skip, jump_offsets, ..
            } => skip + 12 + jump_offsets.len() * 4,
            Self::Idiv => 1,
        }
    }
}

fn table_switch(bytes: &[u8], pc: usize) -> Result<Instruction> {
    let skip = 4 - pc;
    let bytes = &bytes[4 - pc..];
    let default = i32::from_be_bytes(bytes[..4].try_into()?);
    let bytes = &bytes[4..];
    let low = i32::from_be_bytes(bytes[..4].try_into()?);
    let bytes = &bytes[4..];
    let high = i32::from_be_bytes(bytes[..4].try_into()?);

    let mut bytes = &bytes[4..];
    let mut jump_offsets = Vec::new();
    for _ in 0..(high - low + 1) {
        let offset = i32::from_be_bytes(bytes[..4].try_into()?);
        jump_offsets.push(offset);
        bytes = &bytes[4..];
    }

    // FIXME: is skip needed here?
    Ok(Instruction::TableSwitch {
        skip,
        default,
        low,
        high,
        jump_offsets,
    })
}
